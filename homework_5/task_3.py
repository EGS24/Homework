# Задача 3. Кэширование для ускорения вычислений
# Контекст
# Вы разрабатываете программу для оптимизации вычислений чисел
# Фибоначчи. Числа Фибоначчи вычисляются рекурсивной функцией,
# каждое число равно сумме двух предыдущих чисел. Однако вы заметили,
# что при больших значениях чисел Фибоначчи вычисления занимают
# значительное время, так как многие значения вычисляются повторно. Вам
# поручено создать декоратор, который кэширует результаты вызова
# функции и позволяет избежать повторных вычислений для одних и тех же
# аргументов.
# Задача
# Создайте декоратор, который кэширует (сохраняет для дальнейшего
# использования) результаты вызова функции и, при повторном вызове с
# теми же аргументами, возвращает сохранённый результат.
# Примените его к рекурсивной функции вычисления чисел Фибоначчи.
# В итоге декоратор должен проверять аргументы, с которыми вызывается
# функция, и, если такие аргументы уже использовались, должен вернуть
# сохранённый результат вместо запуска расчёта.
# Советы
# - Для хранения результатов удобно использовать словарь, так как поиск
# элементов внутри словаря будет иметь сложность, равную в среднем O(1).
# - При этом не стоит хранить все вычисления в одном словаре, созданном
# снаружи функций (в глобальной области видимости). Лучше создавать
# отдельные словари для каждой декорируемой функции.

def cache_decorator(func):
    cache = {}  # словарь для хранения результатов вызова функции

    def wrapper(n):
        if n not in cache:  # если аргумента нет в кеше, вызываем func(с аргументов) и присваиваем в кеш
            cache[n] = func(n)
        return cache[n]  # если есть в кеше, то просто возвращаем значение

    return wrapper


@cache_decorator
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)


if __name__ == "__main__":
    print(fibonacci(5))  # 5
    print(fibonacci(10))  # 55
    print(fibonacci(5))  # 5 из кеша
    print(fibonacci(10))  # 55 из кеша
